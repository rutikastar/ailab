A*
#include<stdio.h>
#include<limits.h>
#include<stdlib.h>
#define MAX_NODES 5
#define INF INT_MAX
int heuristic[MAX_NODES] = {7, 6, 2, 1, 0};
int adjMatrix[MAX_NODES][MAX_NODES] = {
    {0, 2, 4, 0, 0},
    {2, 0, 1 ,7, 0 },
    {4, 1, 0 , 0, 3},
    {0, 7, 0 , 0 , 2},
    {0, 0 , 3, 2, 0}
};


void astar(int start, int goal){
    int g[MAX_NODES], f[MAX_NODES], parent[MAX_NODES];
    //openlist - nodes to be processed/ checked for neighbours
    //closedlist - nodes who are already processed
    int openList[MAX_NODES], closedList[MAX_NODES];
    int openSize = 0, closedSize = 0;


    for(int i = 0;i<MAX_NODES;i++){
        g[i] = INF;
        f[i] = INF;
        parent[i] = -1;
        openList[i] = 0; //0 means isnt in openlist
        closedList[i] = 0;
    }
    g[start] = 0;
    f[start] = heuristic[start];
    openList[start] = 1; //mark start node as in open list
    openSize = 1;


    while(openSize>0){
        //find node with lowest f(n) in openlist
        int minFn = INF, currentNode = -1;
        for(int i = 0;i<MAX_NODES;i++){
            if(openList[i] == 1 && f[i]<minFn){
                minFn = f[i];
                currentNode = i;
            }
        }
        if(currentNode == -1){break;}
        if(currentNode == goal){break;}


        openList[currentNode] = 0;
        openSize--;
        closedList[currentNode] = 1;
        closedSize++;


        for(int i = 0;i<MAX_NODES;i++){
            if(adjMatrix[currentNode][i] > 0 && closedList[i] == 0){
                int tempG = g[currentNode]+adjMatrix[currentNode][i];
                if(openList[i] == 0 || tempG <g[i]){
                    g[i] = tempG;
                    f[i] = g[i]+heuristic[i];
                    parent[i] = currentNode;
                    openList[i] = 1;
                    openSize++;
                }
            }
        }


    }
    printf("shortest path: ");
    int path[MAX_NODES], idx=0, node = goal;
    while(node!=-1){
        path[idx++] = node;
        node = parent[node];
    }
    for (int i = idx - 1; i >= 0; i--) {
        printf("%d ", path[i]);
    }
    printf("\nTotal cost: %d\n", g[goal]);


}
int main() {
    int start = 0, goal = 4;
    printf("Finding shortest path from %d to %d using A* Algorithm...\n", start, goal);
    astar(start, goal);
    return 0;
}

AO*
#include<stdio.h>
#include<limits.h>
#define n 6
#define inf INT_MAX
int h[n] = {5, 3, 4, 2, 6,0};
int graph[n][n] = {
    {0, 1, 0, 0, 0, 10},  
    {0, 0, 2, 1, 0, 0},  
    {0, 0, 0, 0, 5, 0},  
    {0, 0, 0, 0, 3, 4},  
    {0, 0, 0, 0, 0, 2},  
    {0, 0, 0, 0, 0, 0}
};
int g[n], parent[n], solved[n];


void aostar(int node){
    if(solved[node]){return;}
    int mincost = inf;
    int bestchild = -1;


    for(int i = 0; i < n; i++){
        if(graph[node][i]>0){
            aostar(i);
            int cost = g[i]+graph[node][i];
            if(cost<mincost){
                mincost = cost;
                bestchild = i;
            }
        }
    }
    if(bestchild !=-1){
        g[node] = mincost;
        h[node] = mincost;
        parent[node] = bestchild;
    }
    solved[node] = 1;
}
void printSolution(int start, int goal) {
    printf("optimal path: ");
    int current = start;
    while (current != goal) {
        printf("%d ", current);
        current = parent[current];
    }
    printf("%d\n", goal);
    printf("total cost: %d\n", g[start]);
}


int main() {
    for (int i = 0; i < n; i++) {
        g[i] = inf;
        parent[i] = -1;
        solved[i] = 0;
    }
    g[n-1] = 0;


    int start = 0, goal = 5;
    aostar(start);
    printSolution(start, goal);
}

Graph Coloring
#include<stdio.h>
#include<stdbool.h>
#define N 4
#include<limits.h>


void printsolution(int color[])
{
    printf("solution is - ");
    for(int i = 0;i<N;i++){
        printf("%d ",color[i]);
    }
    printf("\n");
}
bool canColor(int graph[N][N], int color[], int v, int vcolour){
    for(int i =0;i<N;i++){
        if(graph[v][i] && color[i] == vcolour){
            return false;
        }
    }
    return true;
}
bool graphColoringBT(int graph[N][N], int m, int color[], int v){
    if(v==N){
        printsolution(color);
        return true;
    }
    for(int vcolour = 1;vcolour<=m;vcolour++){
        if(canColor(graph, color, v, vcolour)){
            color[v] = vcolour;
            if(graphColoringBT(graph, m,color,v+1)){
                return true;
            }
            color[v] = 0;
        }
    }
    return false;
}


void graphColoring(int graph[N][N], int m){
    int color[N] = {0};
    if(!graphColoringBT(graph, m, color, 0)){
        printf("no solution for this graph\n");
    }
    int maxno = INT_MIN;
    for(int i = 0;i<N;i++){
        if(color[i]>maxno){
            maxno = color[i];
        }
    }
    printf("colors needed- %d",maxno);
}
int main(){
    int graph[N][N] = {
        {0, 1, 1, 1},
        {1, 0, 1, 0},
        {1, 1, 0, 1},
        {1, 0, 1, 0}
    };
    printf("1- green, 2-blue, 3-red\n");


    int m = 5;
    printf("total colors given - %d\n", m);
    graphColoring(graph, m);
    return 0;


}



Best first search
#include <stdio.h>
#include <limits.h>

#define S 6
#define INF INT_MAX

// Heuristic values for each node
int h[S] = {5, 3, 4, 2, 6, 0};

// Adjacency matrix (edges between nodes)
int graph[S][S] = {
    {0, 1, 0, 0, 0, 10},
    {0, 0, 2, 1, 0, 0},
    {0, 0, 0, 0, 5, 0},
    {0, 0, 0, 0, 3, 4},
    {0, 0, 0, 0, 0, 2},
    {0, 0, 0, 0, 0, 0}
};

void bestFirstSearch(int start, int goal) {
    int visited[S] = {0};
    int parent[S];
    for (int i = 0; i < S; i++) parent[i] = -1;

    int open[S];
    int openSize = 0;

    open[openSize++] = start;
    visited[start] = 1;

    while (openSize > 0) {
        // Find node with lowest heuristic in open list
        int minIndex = 0;
        for (int i = 1; i < openSize; i++) {
            if (h[open[i]] < h[open[minIndex]]) {
                minIndex = i;
            }
        }

        // Pop the best node
        int current = open[minIndex];
        open[minIndex] = open[--openSize];

        printf("Visited: %d\n", current);

        if (current == goal) break;

        // Explore neighbors
        for (int i = 0; i < S; i++) {
            if (graph[current][i] > 0 && !visited[i]) {
                visited[i] = 1;
                open[openSize++] = i;
                parent[i] = current;
            }
        }
    }

    // Print path
    if (!visited[goal]) {
        printf("No path found\n");
        return;
    }

    int path[S], idx = 0;
    int temp = goal;
    while (temp != -1) {
        path[idx++] = temp;
        temp = parent[temp];
    }

    printf("Path: ");
    for (int i = idx - 1; i >= 0; i--) {
        printf("%d ", path[i]);
    }
    printf("\n");
}

int main() {
    int start = 0, goal = 5;
    printf("Best-First Search from %d to %d:\n", start, goal);
    bestFirstSearch(start, goal);
    return 0;
}



BFS
#include<stdio.h>
#define n 9
int queue[n];
int graph[n][n]={{0, 1, 0, 0, 0, 0, 0, 0, 0},
{1, 0, 0, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 1, 0 , 0, 0},
{0, 1, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0, 1, 0, 1},
{0, 0, 0, 0, 0, 1, 0, 1, 0},
{0, 0, 0, 1, 0, 0, 1, 0, 1},
{0, 0, 0, 0, 0, 1, 0, 1, 0}};
int front = 0, rear = 0;
int visited[n];
void bfs(int startvertex){
    queue[rear++] = startvertex; //enque
    visited[startvertex] = 1;
    while(front<rear){
        int node = queue[front++];
        printf("%d ", node);
        for(int i = 0;i<n;i++){
            if(graph[node][i]==1 && visited[i]!=1){
                queue[rear++] = i;
                visited[i] = 1;
            }
        }
    }
}
int main(){
    bfs(0);
}

DFS
#include<stdio.h>
#define m 9
int stack[m];
int visited[m];
int graph[m][m] = {{0, 1, 0, 0, 0, 0, 0, 0, 0},
{1, 0, 0, 1, 1, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0, 0, 0, 0},
{0, 1, 1, 0, 0, 1, 0 , 0, 0},
{0, 1, 0, 0, 0, 0, 0, 0, 0},
{0, 0, 0, 1, 0, 0, 1, 0, 1},
{0, 0, 0, 0, 0, 1, 0, 1, 0},
{0, 0, 0, 1, 0, 0, 1, 0, 1},
{0, 0, 0, 0, 0, 1, 0, 1, 0}};
int top = -1;


void dfs(int startvertex){
    stack[++top] = startvertex;
    while(top>-1){
        int node = stack[top--];
        if(!visited[node]){
        printf("%d ", node);
        visited[node] = 1;
        }
        for(int i = 0;i<m;i++){
            if(graph[node][i] == 1 && visited[i]!=1){
                stack[++top] = i;
            }
        }
    }
}
int main(){
    dfs(0);
}

TTT with AI
#include<stdio.h>
#include<limits.h>
#define AI 'X'
#define PLAYER 'O'
char board[3][3];


void initboard(){
    for(int i = 0;i<3;i++){
        for(int j = 0;j<3;j++){
            board[i][j] = ' ';
        }
    }
}
void displayboard(){
    for(int i = 0;i<3;i++){
        for(int j =0;j<3;j++){
            printf("%c ", board[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}
char checkwinner(){
    for(int i = 0;i<3;i++){
        if(board[i][0] == board[i][1] && board[i][1] == board[i][2] && board[i][0]!=' '){
            return board[i][0];
        }
        if(board[0][i] == board[1][i] && board[1][i] == board[2][i] && board[0][i] != ' '){
            return board[0][i];
        }
        if(board[0][0] == board[1][1] && board[1][1] == board[2][2] && board[0][0] != ' '){
            return board[0][0];
        }
        if(board[0][2] == board[1][1] && board[1][1]==board[2][0] && board[0][2]!= ' '){
            return board[0][2];
        }
    }
    return ' ';
}
int isMovesLeft(){
    for(int i = 0;i<3;i++){
        for(int j = 0;j<3;j++){
            if(board[i][j]==' '){
                return 1;
            }
        }
    }
    return 0;
}
int evaluate(){
    char winner = checkwinner();
    if(winner == AI){
        return 10;
    }else if(winner == PLAYER){
        return -10;
    }
    return 0;


}
int minimax(int depth, int isMaximizing){
    int score = evaluate();
    if(score == 10){
        return score;
    }
    if(score==-10){
        return score;


    }
    if(!isMovesLeft()){
        return 0;
    }
    if(isMaximizing){
        int max_eval = INT_MIN;
        for(int i = 0;i<3;i++){
            for(int j = 0;j<3;j++){
                if(board[i][j] == ' '){
                    board[i][j] = AI;
                    int eval = minimax(depth+1, 0);
                    board[i][j] = ' ';
                    if(eval>max_eval){
                        max_eval = eval;
                    }
                }
            }
        }
        return max_eval;
    }
    else{
        int min_eval = INT_MAX;
        for(int i = 0;i<3;i++){
            for(int j = 0;j<3;j++){
                if(board[i][j] == ' '){
                    board[i][j] = PLAYER;
                    int eval = minimax(depth+1, 1);
                    board[i][j] = ' ';
                    if(eval<min_eval){
                        min_eval = eval;
                    }
                }
            }
        }
        return min_eval;
    }
}
int AImoves(){
    int bestmove=INT_MIN, row = -1, col = -1;
    for(int i = 0;i<3;i++){
        for(int j = 0;j<3;j++){
            if(board[i][j] == ' '){
                board[i][j] = AI;
                int eval = minimax(0, 0);
                board[i][j] = ' ';
                if(eval>bestmove){
                    bestmove = eval;
                    row = i;
                    col = j;
                }
            }
        }
    }
    if(row!=-1 && col!=-1){
    board[row][col] = AI;


    printf("AI has played its move \n");
    }
}
int PlayerMoves(){
    int row, col;
    do{
        printf("Enter choice (row, col): \n");
        scanf("%d %d", &row, &col);
        row--;
        col--;
    }while(row<0||row>2||col<0||col>2||board[row][col]!= ' ');
    board[row][col] = PLAYER;
}
int main(){
    initboard();
    displayboard();
    while(1){
        PlayerMoves();
        displayboard();
        if(checkwinner() == PLAYER){
            printf("PLAYER WINS\n");
            break;
        }
        if(!isMovesLeft()){
            printf("DRAW!!");
            break;
        }
        AImoves();
        displayboard();
        if(checkwinner() == AI){
            printf("AI WINS\n");
            break;
        }
        if(!isMovesLeft()){
            printf("DRAW!!");
            break;
        }
    }
}

TTT w/o AI
#include<stdio.h>
char board[3][3];


void initboard(){
    int count = 1;
    for(int i = 0;i<3;i++){
        for(int j = 0;j<3;j++){
            board[i][j] = count+'0';
            count++;
        }
    }
}


void displayboard(){
    printf("\n");
    for(int i = 0;i<3;i++){
        for(int j = 0;j<3;j++){
            printf("%c ", board[i][j]);
        }
        printf("\n");
    }
}


int checkWin(){
    for(int i = 0;i<3;i++){
        if((board[i][0] == board[i][1] && board[i][1] == board[i][2]) || (board[0][i] == board[1][i] && board[1][i] == board[2][i])){
        return 1;
        }
    }
    if((board[0][0] == board[1][1] && board[1][1] == board[2][2]) || (board[0][2] == board[1][1] && board[1][1] == board[2][0])){
        return 1;
    }
    return 0;
}


int isDraw(){
    for(int i = 0;i<3;i++){
        for(int j = 0;j<3;j++){
            if(board[i][j]!='X' && board[i][j] != 'O'){
                return 0; //empty spaces found
            }
        }
    }
    return 1; //no empty spaces draw
}


void playGame(){
    int player = 1, choice, row, col;
    char mark;
    initboard();
    do{
        displayboard();
        player = (player%2)?1:2; //which players chance is it
        mark = (player == 1)?'X':'O'; //if plyer1 - then mark is x, else o


        printf("player %d, pls enter num from 0 to 9: ", player);
        scanf("%d", &choice);
        row = (choice-1)/3;
        col = (choice - 1)%3;


        if(choice < 1 || choice > 9 || board[row][col] == 'X' || board[row][col] == 'O'){
            printf("Invalid move! Try again.\n");
            player--; //same players turn
        }else{
            board[row][col] = mark;
        }


        if(checkWin()){
            displayboard();
            printf("player %d wins!\n", player);
            return;
        }
        player++;


    }while(!isDraw());
    displayboard();
    printf("draw lol\n");
}
int main(){
    playGame();
    return 0;
}

Nqueens
#include<stdio.h>
#include<stdbool.h>
#define N 4




void printBoard(int board[N][N]){
    for(int i =0;i<N;i++){
        for(int j = 0;j<N;j++){
            printf("%c ", board[i][j]?'Q':'.');
        }
        printf("\n");
    }
    printf("\n");
}
bool isSafe(int board[N][N], int row, int col){
    for(int i = 0;i<N;i++){
        if(board[i][col]){
            return false;
        }
    }
    for(int i = row, j= col;i>=0 && j>=0;i--, j--){
        if(board[i][j]){
            return false;
        }
    }
    for(int i = row, j= col;i>=0 && j<N;i--,j++){
        if(board[i][j]){
            return false;
        }
    }
    return true;
}
void nqueens(int board[N][N], int row){
    if(row == N){
        printBoard(board);
        return;
    }
    for(int col = 0;col<N;col++){
        if(isSafe(board, row, col)){
            board[row][col] = 1;
            nqueens(board, row+1);
            board[row][col] = 0;
        }
    }
}
int main(){
    int board[N][N] = {0};
    nqueens(board, 0);
    return 0;
   
}




Prolog
% Define diseases based on symptoms
disease(malaria) :- symptom(fever), symptom(headache), symptom(nausea).
disease(covid) :- symptom(fever), symptom(cough), symptom(fatigue).

% Predicate to ask yes/no questions about symptoms
ask_symptom(Symptom) :-
    format('Do you have ~w? (yes/no) ', [Symptom]),
    read(Response),
    (Response == yes -> assert(symptom(Symptom));
    Response == no -> true;
    write('Please answer yes or no.'), nl, ask_symptom(Symptom)).

% Collect symptoms based on user responses
get_symptoms :-
    ask_symptom(fever),
    ask_symptom(cough),
    ask_symptom(headache),
    ask_symptom(nausea),
    ask_symptom(fatigue).

% Predicate to predict disease based on symptoms
predict_disease :-
    findall(Disease, disease(Disease), Diseases),
    (member(malaria, Diseases) -> write('Possible disease: Malaria'), nl
    ; member(covid, Diseases) -> write('Possible disease: COVID-19'), nl
    ; write('No matching disease found for the provided symptoms.'), nl).

% To start the prediction
start :-
    get_symptoms,
    predict_disease.


food(apple).
food(vegetables).
eats(anil, peanuts).
alive(anil).
food(Y) :- eats(X, Y), \+killed(X).
alive(X) :- \+killed(X).
killed(X) :- \+alive(X).
likes(john, X) :- food(X).
eats(harry, X) :- eats(anil, X).

